---
title: "IBM Summary"
author: "Malavika Rajeev"
date: "1/24/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Individual based model 
This is an adapted version of Elaine/Rebecca/Isty's models. It's discretized to a weekly timestep. All transitions are specified as sequential binomial probabilities to maximize computational efficiency.

### Demography

            - susceptibility is determined by vaccination, population sizes, and growth at the
              village level and then disaggregated to the given scale as follows:
                - Dog Population
                  - Starting pop size = village human pop from 2002 census/HDR from dog census
                  - Allocate pop using multinomial probabilities = to the proportion of the *dog*
                    population in each grid cell for a given village
                  - Growth rate for each grid cell is taken from the village growth rate from the 
                    2002 to the 2012 census and you simulate forward
                - Vaccination
                  - Numbers vaccinated weekly for each village
                  - Your probability of vaccination is either
                      - probability of being vaccinated in a village multiplied by the probability 
                        that given you are vaccinated, you are in a given grid cell
                      - OR the # vaccinated in that village allocated by the proportion of the dog pop                         in that grid cell (as with pop allocation)
                          - for this option you need to be able to allocate leftovers to adjacent vills
                      - Revaccination
                        - Assume that if an event constitutes a campaign, then n - 100% of individuals                           are revaccinated (assumes that once vaccinated individuals have higher 
                          probability of being vaccinated than non-vaccinated)
                        - OR that vaccinated and unvaccinated individuals have the same probability of
                          being vaccinated (option 1 above)
### Vaccination

### Transmission
The number of secondary cases for each individual is drawn from a negative binomial distribution with mean R_0 (i.e. the mean number of secondary cases in a completely susceptible population) and k (the dispersion parameter). Transmission failure due to reasons other than contact with a non-susceptible (i.e. failure for the virus to establish in a bitten dog, killing of exposed dogs, etc.) are implicit. The dispersion parameter also accounts implicitly for rabid cases where dogs are tied or killed after displaying symptoms, paralytic forms, biting other dead-end hosts, etc. 

Movement is in continuous space and is sequential; that is, infected individuals move sequentially for n number of secondary contacts. If an individual moves to an unoccupied cell or outside of the district, the step length and location are drawn again (1) (+ look up how to insert footnotes R markdown). 

The probability that a transmission event is successful (i.e. probability that a given contact is with a suspectible) is the proportion susceptible in that cell (S/N). This implicitly accounts for rebiting of exposed/infecteds and of course, vaccination. 

*(1). This might have interesting implications if we were to estimate R_0. I think Dan mentioned this, but there are likely a small % of rabid dogs that leave the district or waste contact time roaming, so would be interesting to see if we allowed for this (nullifying the secondary transmission for those dogs in the district) if we would see that we need higher R_0 to observe our ts).*

Incursions happen at some rate *iota*
                - either constant 
                         OR pulsed
        by distance from edge?

### Simulation time 
- largely depends on the # of infecteds in the population (so larger pops + R0s will take a longer time).
- show relationship between # of cases and sim time...

## Preliminary simulations
### Endemic SD
```{r}
sims_SD <- read.csv("output/simsSD/Imat_SDvacc.csv")
sims_SD <- data.table::melt(sims_SD, id.vars = 1, variable.name = "nsim", value.name = "cases")
rabies_ts <- read.csv("data/cases.csv")

sims_SD %>%
  group_by(X) %>%
  summarize(sd = sd(cases, na.rm = TRUE), cases = mean(cases, na.rm = TRUE),
            upper = cases + sd*1.96, lower = cases - sd*1.96, 
            lower = ifelse(lower < 0, 0, lower)) -> sims_summed
set.seed(125)
ggplot(data = sims_summed, aes(x = X, y = cases)) +
  geom_line(color = "darkred") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "red", alpha = 0.5) +
  geom_line(data = rabies_ts, aes(x = times, y = cases), color = "darkred") + 
  geom_line(data = filter(sims_SD, nsim == sample(nsim, 2, replace = FALSE)), 
                          aes(x = X, y = cases, group = nsim), color = "pink",
            linetype = 2) +
  ylim(c(0, 200)) +
  xlab("Months") +
  ylab("Cases") +
  labs(title = "With SD vaccination")

sims_SD <- read.csv("output/simsSD/Imat_SDendemic.csv")
sims_SD <- data.table::melt(sims_SD, id.vars = 1, variable.name = "nsim", value.name = "cases")

sims_SD %>%
  group_by(X) %>%
  summarize(sd = sd(cases, na.rm = TRUE), cases = median(cases, na.rm = TRUE),
            upper = cases + sd*1.96, lower = cases - sd*1.96,
            lower = ifelse(lower < 0, 0, lower)) -> sims_summed
set.seed(138)
ggplot(data = sims_summed, aes(x = X, y = cases)) +
  geom_line(color = "red") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "red", alpha = 0.5) +
  geom_line(data = filter(sims_SD, nsim == sample(nsim, 2, replace = FALSE)), 
                          aes(x = X, y = cases, group = nsim), color = "pink",
            linetype = 2) +
  xlab("Months") +
  ylab("Cases") +
  labs(title = "Endemic (no vaccination scenario)")


sims_SD <- read.csv("output/simsSD/Nmat_SDendemic.csv")
sims_SD <- data.table::melt(sims_SD, id.vars = 1, variable.name = "nsim", value.name = "cases")

sims_SD %>%
  group_by(X) %>%
  summarize(sd = sd(cases, na.rm = TRUE), cases = median(cases, na.rm = TRUE),
            upper = cases + sd*1.96, lower = cases - sd*1.96) -> sims_summed
ggplot(data = sims_summed, aes(x = X, y = cases)) +
  geom_line(color = "blue") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "blue", alpha = 0.5) +
  xlab("Months") +
  ylab("Dog Population") +
  labs(title = "Dog population growth w/ endemic incidence")

sims_SD <- read.csv("output/simsSD/Imat_SDelim.csv")
sims_SD <- data.table::melt(sims_SD, id.vars = 1, variable.name = "nsim", value.name = "cases")

set.seed(126)
sims_SD %>%
  group_by(X) %>%
  summarize(sd = sd(cases, na.rm = TRUE), cases = mean(cases, na.rm = TRUE),
            upper = cases + sd*1.96, lower = cases - sd*1.96,
            lower = ifelse(lower < 0, 0, lower)) -> sims_summed
ggplot(data = sims_summed, aes(x = X, y = cases)) +
  geom_line(color = "red") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "red", alpha = 0.5) +
  xlab("Months") +
  ylim(c(0, 200)) +
  labs(title = "Elimination scenario")

## coverage at 70/100
S_SD <- read.csv("output/simsSD/Smat_SDelim.csv")
N_SD <- read.csv("output/simsSD/Nmat_SDelim.csv")

S_SD <- data.table::melt(S_SD, id.vars = 1, variable.name = "nsim", value.name = "S")
N_SD <- data.table::melt(N_SD, id.vars = 1, variable.name = "nsim", value.name = "N")
S_SD %>%
  left_join(N_SD) %>%
  mutate(cov = 1 - S/N) %>%
  group_by(X) %>%
  summarize(sd = sd(cov, na.rm = TRUE), cov = mean(cov, na.rm = TRUE),
            upper = cov + sd*1.96, lower = cov - sd*1.96) -> sims_summed
ggplot(data = sims_summed, aes(x = X, y = cov)) +
  geom_line(color = "blue") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "blue", alpha = 0.5) +
  xlab("Months") +
  ylab("Dog Population") +
  labs(title = "Coverage")

sims_SD <- read.csv("output/simsSD/Imat_SDelim.csv")
sims_SD <- data.table::melt(sims_SD, id.vars = 1, variable.name = "nsim", value.name = "cases")

set.seed(126)
sims_SD %>%
  group_by(X) %>%
  summarize(sd = sd(cases, na.rm = TRUE), cases = mean(cases, na.rm = TRUE),
            upper = cases + sd*1.96, lower = cases - sd*1.96,
            lower = ifelse(lower < 0, 0, lower)) -> sims_summed
ggplot(data = sims_summed, aes(x = X, y = cases)) +
  geom_line(color = "red") +
  geom_ribbon(aes(ymin = lower, ymax = upper), fill = "red", alpha = 0.5) +
  xlab("Months") +
  labs(title = "Elimination scenario") 

```


### Percolation
```{r}
perc_vill <- read.csv("output/perc/perc_vill.csv")
perc_vill %>%
  group_by(perc, cov) %>%
  summarize(chain_length = mean(chain_length), secondaries = mean(secondaries),
            max_secondaries = min(secondaries)) %>%
  filter(cov != 0, perc != 0) -> perc_vill
library(plotly)

perc_vill %>%
  select(perc, cov, secondaries) %>%
  spread(perc, secondaries) %>%
  as.matrix(.) -> perc_mat
perc_mat <- perc_mat[, -1]
p <- plot_ly(
  type = 'contour',
  z = perc_mat/5,
  x = seq(0.1, 1.0, by = 0.1),
  y = seq(0.1, 1.0, by = 0.1),
  contours = list(coloring = 'heatmap', showlabels = TRUE)
)  %>%
  layout(xaxis = list(title = "Coverage"), yaxis = list(title = "Proportion of villages"))
p

perc_vill %>%
  select(perc, cov, chain_length) %>%
  spread(perc, chain_length) %>%
  as.matrix(.) -> perc_mat
perc_mat <- perc_mat[, -1]
p <- plot_ly(
  type = 'contour',
  z = perc_mat,
  x = seq(0.1, 1.0, by = 0.1),
  y = seq(0.1, 1.0, by = 0.1),
  contours = list(
    coloring = 'heatmap', showlabels = TRUE
  )
) %>%
  layout(xaxis = list(title = "Coverage"), yaxis = list(title = "Proportion of villages"))
p

ggplot(data = perc_vill, aes(x = as.factor(cov), y = secondaries, col = perc)) +
  geom_point() +
  scale_fill_gradient(low = "white", high = "red")

```

### Scaling down introductions

```{r}
perc_vill <- read.csv("output/perc/perc_vill_scaleIntros.csv")
perc_vill %>%
  group_by(perc, cov) %>%
  summarize(chain_length = mean(chain_length), secondaries = mean(secondaries),
            max_secondaries = min(secondaries)) %>%
  filter(cov != 0, perc != 0) -> perc_vill
ggplot(data = perc_vill, aes(x = cov, y = perc, fill = secondaries)) +
  geom_tile() +
  scale_fill_gradient(low = "white", high = "red")
library(plotly)

perc_vill %>%
  select(perc, cov, secondaries) %>%
  spread(perc, secondaries) %>%
  as.matrix(.) -> perc_mat
perc_mat <- perc_mat[, -1]
p <- plot_ly(
  type = 'contour',
  z = perc_mat/5,
  x = seq(0.1, 1.0, by = 0.1),
  y = seq(0.1, 1.0, by = 0.1),
  contours = list(coloring = 'heatmap', showlabels = TRUE)
) %>%
  layout(xaxis = list(title = "Coverage"), yaxis = list(title = "Proportion of villages"))
p

perc_vill %>%
  select(perc, cov, chain_length) %>%
  spread(perc, chain_length) %>%
  as.matrix(.) -> perc_mat
perc_mat <- perc_mat[, -1]
p <- plot_ly(
  type = 'contour',
  z = perc_mat,
  x = seq(0.1, 1.0, by = 0.1),
  y = seq(0.1, 1.0, by = 0.1),
  contours = list(
    coloring = 'heatmap', showlabels = TRUE
  ) 
) %>%
  layout(xaxis = list(title = "Coverage"), yaxis = list(title = "Proportion of villages"))
p

ggplot(data = perc_vill, aes(x = as.factor(cov), y = secondaries, col = perc)) +
  geom_point() +
  scale_fill_gradient(low = "white", high = "red")

```


## Estimation using synthetic likelihood

## Scaling up: IBM
### Endemic SD
### Endemic no-control
### Elimination

## Scaling up: metapopulation

## Scaling up: non-spatial model
### Endemic SD
#### Base
#### With connectivity candidates

